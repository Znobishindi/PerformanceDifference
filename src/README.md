# Результаты эксперимента:

### При добавлении 10 000 элементов:
* Добавление элементов в synchronizedMap в десятки раз быстрее, чем в concurrentHashMap (2 млс против 50 млс).
* Параллельное чтение (по 2 потока) +- одинаковое (в среднем 3-4 млс)
### При добавлении 1 000 000 элементов:
* Добавление элементов в synchronizedMap почти в 2 раза быстрее, чем в concurrentHashMap (182 млс против 355 млс).
* Параллельное чтение (по 2 потока) быстрее из synchronizedMap (28 млс против 40 млс)
### При добавлении 5 000 000 элементов:
* Добавление элементов в synchronizedMap почти в 2 раза быстрее, чем в concurrentHashMap (963 млс против 1936 млс).
* Параллельное чтение (по 2 потока) +- одинаковое (в среднем 140 млс) 
### При добавлении 10 000 000 элементов:
* Добавление элементов в synchronizedMap почти в 2 раза быстрее, чем в concurrentHashMap (1654 млс против 3202 млс).
* А вот параллельное чтение (по 2 потока) теперь гораздо лучше выглядит у concurrentHashMap (186 млс против 580 млс) 
* ### При добавлении 15 000 000 элементов:
* Добавление элементов в synchronizedMap почти в 2 раза быстрее, чем в concurrentHashMap (2600 млс против 4500 млс).
* А вот параллельное чтение (по 2 потока) по прежнему гораздо лучше выглядит у concurrentHashMap (220 млс против 750 млс)
## Вывод:
* Добавление элементов в synchronizedMap происходит быстрее, чем в concurrentHashMap, особенно когда добавляемых элементов немного.
* С чтением ситуация интереснее: где-то до 5 000 000 элементов synchronizedMap справлялся с этой задачей быстрее, а вот больше 5 000 000 элементов concurrentHashMap читает быстрее.
